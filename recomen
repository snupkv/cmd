import { SecretServiceV2 } from './secretService';
import { SecretsManagerClient, GetSecretValueCommand } from '@aws-sdk/client-secrets-manager';

vi.mock('@aws-sdk/client-secrets-manager', () => ({
  SecretsManagerClient: vi.fn(),
  GetSecretValueCommand: vi.fn(),
}));

describe('SecretServiceV2 - readAllSecrets', () => {
  const mockSend = vi.fn();

  beforeEach(() => {
    vi.clearAllMocks();
    (SecretServiceV2 as any).instance = undefined;
    (SecretServiceV2 as any).client = undefined;
    process.env = { ...process.env }; // Reset ENV

    (SecretsManagerClient as unknown as vi.Mock).mockImplementation(() => ({
      send: mockSend,
    }));
  });

  it('should initialize SecretsManagerClient only once', () => {
    process.env.AWS_REGION = 'us-east-1';

    const svc = SecretServiceV2.getInstance();
    svc.initializeClient();
    svc.initializeClient();

    expect(SecretsManagerClient).toHaveBeenCalledTimes(1);
  });

  it('should fetch secrets from Secrets Manager and store in process.env', async () => {
    process.env.AWS_REGION = 'us-east-1';
    process.env['SECRET_MANAGER_KEY_1'] = 'cof/cos/BABAINTEGRATEDCHANNELMANAGEMENT/1/myParam';

    mockSend.mockResolvedValue({
      SecretString: JSON.stringify({ myParam: 'myValue' }),
    });

    const svc = SecretServiceV2.getInstance();
    await svc.readAllSecrets();

    expect(mockSend).toHaveBeenCalledTimes(1);
    expect(process.env['SECRET_MANAGER_KEY_1']).toBe('myValue');
  });

  it('should skip SecretsManager if secret exists in process.env', async () => {
    process.env['SECRET_MANAGER_KEY_1'] = 'cof/cos/BABAINTEGRATEDCHANNELMANAGEMENT/1/myParam';
    process.env['myParam'] = 'preSet';

    const svc = SecretServiceV2.getInstance();
    await svc.readAllSecrets();

    expect(mockSend).not.toHaveBeenCalled();
  });

  it('should throw if Secrets Manager returns no SecretString', async () => {
    process.env.AWS_REGION = 'us-east-1';
    process.env['SECRET_MANAGER_KEY_1'] = 'cof/cos/BABAINTEGRATEDCHANNELMANAGEMENT/1/missingParam';

    mockSend.mockResolvedValue({});

    const svc = SecretServiceV2.getInstance();

    await expect(svc.readAllSecrets()).rejects.toThrowError(/Error fetching secrets/);
  });

  it('should throw if SecretString is invalid JSON', async () => {
    process.env.AWS_REGION = 'us-east-1';
    process.env['SECRET_MANAGER_KEY_1'] = 'cof/cos/BABAINTEGRATEDCHANNELMANAGEMENT/1/badJson';

    mockSend.mockResolvedValue({
      SecretString: 'not-a-valid-json',
    });

    const svc = SecretServiceV2.getInstance();

    await expect(svc.readAllSecrets()).rejects.toThrowError(/Error fetching secrets/);
  });

  it('should log and throw on fetch error', async () => {
    process.env.AWS_REGION = 'us-east-1';
    process.env['SECRET_MANAGER_KEY_1'] = 'cof/cos/BABAINTEGRATEDCHANNELMANAGEMENT/1/param';

    const mockError = new Error('AWS error');
    mockSend.mockRejectedValue(mockError);

    const svc = SecretServiceV2.getInstance();
    const spyLogger = vi.spyOn(svc as any, 'logger', 'get').mockReturnValue({
      error: vi.fn(),
    });

    await expect(svc.readAllSecrets()).rejects.toThrowError(/AWS error/);

    expect(spyLogger().error).toHaveBeenCalledWith(expect.stringContaining('Error fetching secrets'));
  });
});
